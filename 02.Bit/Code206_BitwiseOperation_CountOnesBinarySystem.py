#############################################################################
# 返回n的二进制中有几个1
# 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
# 给你两个整数 x 和 y，计算并返回它们之间的汉明距离
#
# 测试链接 : https://leetcode.cn/problems/hamming-distance/
#
#方法一： 最优，分组累加
#方法三： 次优，循环查看最右侧1 (Brian Kernighan算法)
#方法二： 暴力，循环查看每一位是不是1
#############################################################################

#方法一： 分组累加
def CountOnesBinarySystem(x, y):
    return cntOnes(x ^ y)

def cntOnes(n):
    n = (n & 0x55555555) + ((n >> 1) & 0x55555555)   #  01010101010101010101010101010101,  计算相邻2位上1的个数
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)   #  00110011001100110011001100110011， 计算相邻4位上1的个数
    n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f)   #  00001111000011110000111100001111， 计算相邻8位上1的个数
    n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff)   #  00000000111111110000000011111111， 计算相邻16位上1的个数
    n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff)  #  00000000000000001111111111111111， 计算32位上1的个数
    return n

#---------------------------------------------------------------------------------

#方法二：  循环查看最右侧1 (Brian Kernighan算法)
def CountOnesBinarySystem2(x, y):
    n = x ^ y
    res = 0
    while n:
        rightOne = n & -n
        n -= rightOne
        res += 1
    return res

#---------------------------------------------------------------------------------

#方法三：  循环查看每一位是不是1
def CountOnesBinarySystem3(x, y):
    n = x ^ y
    res = 0
    while n:
        res += (n & 1) 
        n = n >> 1
    return res


#---------------------------------------------------------------------------------

def main():   
    x, y = 10, 50
    print(CountOnesBinarySystem(x, y))
    print(CountOnesBinarySystem2(x, y))
    print(CountOnesBinarySystem3(x, y))

if __name__ == "__main__":
    main()   